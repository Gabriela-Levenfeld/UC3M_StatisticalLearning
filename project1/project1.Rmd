---
title: 'Project 1: Statistical Tools'
author: "Gabriela Levenfeld Sabau"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: '6'
    df_print: paged
  geometry: left=3cm,right=3cm,top=2cm,bottom=2cm
  mathjax: local
  self_contained: false
  word_document:
    toc: true
    toc_depth: '6'
  pdf_document:
    latex_engine: xelatex
    toc: true
    toc_depth: 6
    keep_tex: true
subtitle: MS in Statistics for Data Science
bibliography: references.bib
nocite: '@*'
link-citations: true
linkcolor: blue
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
```

\pagebreak

# Introduction

## Dataset description

Data can be found in Kaggle: <https://www.kaggle.com/datasets/blastchar/telco-customer-churn>.

It contains information from $7043$ clients distributed into $21$ different variables.

This dataset is made in order to predict *customer churn*. In the business sector, in order to make a profit, the number of customers gained and lost is really important. It not only allow us to compute the benefit that a company can have, it is also a good metric to evaluate and get insight about the strategy we are employing. This, let us to make decisions to make the next steps.

## Variables description

The information contained in this dataset can be group into different areas.

\underline{Personal information about the customer}.

- `customerID`: Unique identifier for the client.

- `gender`: Female or Male.

- `SeniorCitizen`: Binary variable that indicates if >65 (yes) or not (no).

- `Partner`: Whether the customer has a partner or not (Yes, No).

- `Dependents`: Variables which storage if the client lives with more people (children, parents, grandparents,...).

\underline{Services subscribed}.

- `tenure`: Indicates the total amount of months that the customer has been with the company by the end of the 3Q (third quarter).

- `PhoneService`: Yes if client is subscribed to home phone service with the company and No if not.

- `MultipleLines`: Yes if the client has more than 1 telephone lines with the company and No if just one.

- `InternetService`:  Indicates if the customer subscribes to Internet service with the company: No, DSL, Fiber Optic, Cable. 4 options are available.

- `OnlineSecurity`: Yes if the client has online security service (extra service) provided by the company and No if not.

- `OnlineBackup`:  Indicates if the customer subscribes to an additional online backup service provided by the company: Yes, No.

- `DeviceProtection`: Indicates if the customer subscribes to an additional device protection plan for their Internet equipment provided by the company: Yes, No.

- `TechSupport`: Indicates if the customer subscribes to an additional technical support plan from the company with reduced wait times: Yes, No.

- `StreamingTV`: Indicates if the customer uses their Internet service to stream television programing from a third party provider: Yes, No. The company does not charge an additional fee for this service.

- `StreamingMovies`: Indicates if the customer uses their Internet service to stream movies from a third party provider: Yes, No. The company does not charge an additional fee for this service

\underline{Account information}

- `Contract`: Indicates the customer’s current contract type: Month-to-Month, One Year, Two Year.

- `PaperlessBilling`: Indicates if the customer has chosen paperless billing: Yes, No.

- `PaymentMethod`: Indicates how the customer pays their bill: Bank Withdrawal, Credit Card, Mailed Check.

- `MonthlyCharges`:  Indicates the customer’s current total monthly charge for all their services from the company.

- `TotalCharges`: Indicates the customer’s total charges, calculated to the end of the 3Q (third quarter).

\underline{Target variable}

- `Churn`: Yes = the customer left the company this quarter. No = the customer remained with the company.


## Goal

Prediction over the `Churn` variable. Binary classification problem, where we want to predict is a client is going to continue with the services provided by the company. Or if he is going to leave.

\pagebreak
# Data preprocessing

In this first section, we must prepare the dataset in order to use it for the computational model. This means handling missing data, deleting unnecessary information, encoding categorical variables and splitting the data, among other.


## 1. Load material.

**Load libraries**. Several libraries are need for the project in order to work properly.

```{r load_libraries, message=FALSE, warning=FALSE}
library(skimr)
library(tidyverse) # For glimpse
library(dplyr) # mutate function
library(mice) # Imputation
library(VIM) # Imputation graph
library(fastDummies) # For encoding multi-state variables
library(caret) # For split the dataset
```

**Load dataset**.

```{r load_data}
# Load the dataset for this project
data <- read.csv("Telco-Customer-Churn.csv", header = TRUE, sep = ",")
```

**First look at the dataset**.

```{r small_EDA}
# Small Exploratory Data Analysis
skim(data)
# Presents results for every column; the statistics it provides depend on the class of the variable

glimpse(data)

# For visualize the first 2 rows
head(data, 2)
```

## 2. Delete unnecessary information.

Thanks to the above function, we realized we can remove the ID column (`customerID`) because it will not be useful for making predictions. On the other hand, `PaperlessBilling` is also removed, due to nowadays we live in a digital era thus most people choose electronic payments and it will not really provide any additional information to the problem we are dealing with.

```{r rmv_columns}
# Remove ID column 
data <- data %>% select(-c(customerID, PaperlessBilling))
```

## 3. Data cleaning.

By analyzing the dataset we can realized that there exists some variables that are quite intertwine.

\underline{Combine `PhoneService` and `MultipleLines`}. The first variable indicates if the client has sign up for home phone service or not. Only when the client has hired for this service, he can choose between having $1$ phone line (`MultipleLines`=No) or have more than $1$ (`MultipleLines`=Yes). This relationship lead us into three possible scenarios:

1. `PhoneService`=No and `MultipleLines`="No phone service". Customers who do not have phone service.

2. `PhoneService`=Yes and `MultipleLines`=No. Customers who have phone service and choose to have a single line.

3. `PhoneService`=Yes and `MultipleLines`=Yes. Customers who have phone service and choose to have multiple lines.

Since `MultipleLines` can be consider to have all the information needed, I will combine this two variables on a new parameter named `PhoneServiceType` and treat it as a multi-state category with three options:

- $0$: if there is no phone service.

- $1$: if there is phone service with a single line.

- $2$: if there is phone service with multiple lines.

\underline{`InternetService` and its associate variables}. Something similar happend on this situation. Clients who have no sign up for Internet service, they are no be able to sign up for extra-services associated with it such as `OnlineSecurity`, `StreamingTV`, among others. The dataset storage this information of extra-services with "Yes", "No" or "No internet service". It is clearly that we can reduce this multi-state variables issue into a binary class. So "No phone service" will be understand simply as the customer does not have this service on (setting the parameter value into "No").

**Note**: For both situation, we check there was no mistake on the data. So it has been computationally verified that there is concordance between the relationships of these variables. Thus avoiding the existence of possible nonsence situations. 


```{r data_manipulation}
## Unique values of each variable ----------------------------------------------
unique(data$SeniorCitizen) # It is already transform in 1's and 0's

cat_vars <- sapply(data, is.character) # Select qualitative variables
lapply(data[, cat_vars], unique) # Print unique values


## PhoneService and MultipleLines ----------------------------------------------
# Subset with clients where PhoneService is "No"
subset_no_Phone <- data[data$PhoneService == "No", ]
# Check MultipleLines is set to "No phone service"
if (all(subset_no_Phone$MultipleLines == "No phone service")) {
  cat("In the subset where PhoneService is 'No', 
      MultipleLines is set to 'No phone service' only.\n")
} else {
  cat("In the subset where PhoneService is 'No', 
      MultipleLines is not exclusively set to 'No phone service'.\n")
}

# Combine PhoneService and MultipleLines on a new variable (PhoneServiceType)
data <- data %>%
  mutate(PhoneServiceType = case_when(
    MultipleLines == "No phone service" ~ 0,
    MultipleLines == "No" ~ 1,
    TRUE ~ 2
  ))

# Remove original variables
data <- select(data, -PhoneService, -MultipleLines)


## Consequences Internet service -----------------------------------------------
# Subset with clients where InternetService is "No"
subset_no_Internet <- data[data$InternetService == "No", ]

vars_to_check <- c("OnlineSecurity", "OnlineBackup", "DeviceProtection",
                   "TechSupport", "StreamingTV", "StreamingMovies")

# Check its associate variables are set to "No internet service"
for (variable in vars_to_check) {
  unique_values <- unique(subset_no_Internet[[variable]])
  cat("Unique values for", variable, ":", unique_values)
  cat("\n")
}

# Reduce the associate variables to a binary class ("No internet service" -> "No")
for (variable in vars_to_check) {
  data[[variable]] <- ifelse(data[[variable]] == "No internet service", "No", data[[variable]])
}
```

## 4. Handling missing data.

On this dataset there are some missing values contained in the variable `TotalCharges` which we need to handle it first in order to be able to use the statistical tools after.

Take in mind, these values represent only $0.1561834\%$ of customers in the dataset, the following approach could be followed:

- **Delete this rows**; due to the low presence of missing values the data will not be affected.

- **Set to $0$**; these observations correspond to new clients, therefore, not it has not passed enough time to compute this value.

- **Imputation**; selected option thereby some techniques seen during lecture can be apply.

For imputing the missing data the R library call `mice` is used. Instead of making a random prediction, `mice` by default makes $5$. However, in this exercise we will only choose the first of the five. Additionally, the method we will use will be 'pmm', which stands for predictive mean matching. That is, the data will be imputed taking the mean as a reference. Once we have generated the imputed data, we have to introduce it in our data. The easiest way to do this is with the `complete()` function, which complete the missing values with the values of the first imputation of the five that we just made.

To check there is no missing data anymore, we use a graph from `library(VIM)` that represent the percentage of missing data.

To check whether the imputed data adequately follows the distributions of the original data, we are going to use the `densityplot()` function, which shows us the marginal distribution of the observed data in blue; and in red, the $m=5$ densities for the predictor that has initially missing data which is `TotalCharges`. That is why, in the following graph, we observe $5$ functions in red, each corresponding to a repetition of the imputed data by `mice`.

```{r handling_NAs, fig.width=4, fig.height=3, fig.align='center'}
# Counting NA's ----------------------------------------------------------------
missing_values <- colSums(is.na(data)) # 11 NA's in TotalCharges variable
percentage_na <- missing_values/nrow(data)*100 # NA's in %
sort(percentage_na, decreasing = TRUE)

# Get the index of the rows where TotalCharges=NA
index_TotalCharges_na <- which(is.na(data$TotalCharges))
print(index_TotalCharges_na)


## MICE Imputation -------------------------------------------------------------
meth <- rep("", ncol(data)) # Set all methods to "" (no imputation)
names(meth)[names(meth) == "TotalCharges"] <- "pmm" # Specify TotalCharges method

mice_model <- mice(data,
  m = 5, maxit = 5, method = "pmm",
  seed = 1234, print = FALSE
)
data <- complete(mice_model, 1) # Complete the data with the first imputation

# Represent the % of missing data
aggr(data,
  col = c("navyblue", "yellow"), numbers = TRUE, sortVars = FALSE,
  labels = names(data), cex.axis = .7, gap = 3,
  ylab = c("Missing data", "Real data")
)

# Check it follows the distribution of the original variable
densityplot(mice_model, scales = list(x = list(relation = "free")))
```

Due to it does not fit properly, as we can see on the density plot, I believe setting this observation to $0$ is the best option, among all.

```{r}
# TODO: Establecer estas filas a cero (?) o dejo la imputation.
print(data[489,]) # User with TotalCharges=NA, after imputation
print(data[490,]) # Normal user
```


## 5. Encoding categorical variables.

**Categorical variables**.

- Binary variables. $11$: `gender`, `SeniorCitizen`, `Partner`, `Dependents`, `OnlineSecurity`, `OnlineBackup`, `DeviceProtection`, `TechSupport`, `StreamingTV`, `StreamingMovies` and `Churn`.

For these variables, I will establish "No" values as $0$ and "Yes" as $1$'s.

- Multi-sate variables. $4$: `InternetService`, `Contract`,  `PaymentMethod`, `PhoneServiceType`.

On the other hand, to manage this section is a little bit more complicated and we need to be aware of the presence or absence of some natural order on it.

Strategy 1: Natural order.
`PhoneServiceType` preserve a natural order. As a consequence this parameter, will be encode preserving the order. It is worth to mention that `PhoneServiceType` is already encode. And the idea explained above has been apply, values set as $0$, $1$ and $2$.

Strategy 2: No order.
For the second set of categorical parameter (`InternetService`, `Contract` and `PaymentMethod`). I will create dummy variables, known as one-hot encoding. This is because, for instance, on the `InternetService` parameter, "Fiber Optic" is not inherently greater than "DSL". Same happens with the rest of variables mention.

```{r}
## Binary encoding -------------------------------------------------------------
data$gender <- as.integer(data$gender == "Female") # Assuming Female:1, Male:0

binary_variables <- c(
  "Partner", "Dependents", "OnlineSecurity", "OnlineBackup",
  "DeviceProtection", "TechSupport", "StreamingTV",
  "StreamingMovies", "Churn"
)
# Assuming Yes:1, No:0
data[binary_variables] <- lapply(data[binary_variables],
                                 function(x) as.integer(x == "Yes"))


## Multi-state variables -------------------------------------------------------
# Dummy variables creation
data <- dummy_cols(data, 
                   select_columns = c("InternetService", "Contract", "PaymentMethod"),
                   remove_selected_columns = TRUE,
                   remove_first_dummy = TRUE)
```


# Exploratory Data Analysis (EDA)






**Quantitative variables**.

- $3$: `tenure`, `MonthlyCharges`, `TotalCharges`.

```{r, eval=FALSE}
numeric_variables <- c('tenure', 'MonthlyCharges', 'TotalCharges')

# Scalar los datos numeric
```
## 6. Check unbalance target

```{r eval=FALSE}
table(data$Churn)
```

## 7. Split the dataset

```{r eval=FALSE}
# Split into training and testing set
set.seed(1234) # For reproducibility
index <- createDataPartition(data$Churn, p=0.8, list=FALSE)

X_train <- data[index,]
X_test <- data[-index,]
y_train <- data[index,]$Churn
y_test <- data[-index,]$Churn

# In order to check proportion are still the same
table(data$Churn)/length(data$Churn)
table(X_train$Churn)/length(X_train$Churn)
table(X_test$Churn)/length(X_test$Churn)
```





# Statistical tools
## LDA
## QDA
## Más modelos


# Conclusion

# References

```{r eval=FALSE, echo=FALSE}
# Returns the names of all packages loaded in the current R session
# knitr::write_bib(.packages(), "references.bib")
```

<div id="refs"></div>
